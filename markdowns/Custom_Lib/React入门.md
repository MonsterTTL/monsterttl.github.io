# React入门

# JSX语法

在React中，允许我们使用JSX语法来描述UI。JSX是JavaScript的语法扩展，它允许我们使用类似于HTML的语法来描述UI，即我们可以
在JavaScript脚本文件中编写HTML代码：

```javascript
import React from 'react';
const element = <h1>Hello, world!</h1>;
```

这本质上是一种语法糖，比如Android开发中的Compose，底层的实现上实际上还是操作DOM元素。

# Hook函数
在 React 中，Hook（钩子函数）是 React 16.8 引入的一种新特性，它允许函数组件拥有类似类组件中的一些功能，如状态管理、生命周期方法等。
Hook 的出现大大简化了 React 代码的结构，使得函数组件变得更加灵活和强大。
## useState函数
useState函数是React中用于管理状态的一个函数，它返回一个数组，数组中包含两个元素：当前状态和更新状态的函数。这
乍一看和我们直接使用变量的方式没什么区别，但是useState函数会帮助我们进行状态管理，它确保状态更新后，UI 会自动反应到最新的状态。
而普通变量无法做到这一点，因此在需要动态交互和状态变化的场景中，应该始终使用 useState。

| 特性       | useState              | 普通变量            |
|----------|-----------------------|-----------------|
| 状态管理     | 管理组件的状态并保留其值          | 没有持久化，只会在渲染时初始化 |
| 触发组件更新   | 状态变化时触发组件重新渲染         | 不会触发组件重新渲染      |
| 状态持久化    | 会在不同的渲染周期之间保持最新的值     | 每次重新渲染时重置       |
| 用于动态数据渲染 | 是 React 推荐的做法，适用于动态数据 | 不适合动态变化的状态管理    |
| 性能优化     | React 会批量更新和优化渲染      | 不支持 React 的渲染优化 |

*注意⚠️：调用 set 函数 不会 改变已经执行的代码中当前的 state，它只影响 下一次 渲染中 useState 返回的内容。*

## 状态管理（重要）
从使用useState函数入门，其实我们就已经开始使用状态管理了。通常来说，*如果一个脚本中有变量，
那么每当这个脚本被重新执行时，这个变量都会重置为初始值，即它的状态值会丢失*。这显然是十分棘手的，
因为当数据发生改变的时候我们往往都需要更新UI，这个时候就会触发组件的重新渲染，即脚本的重新执行，
这就造成了一种矛盾：
```
变量状态改变 => 需要更新UI => 触发组件重新渲染 => 脚本重新执行 => 变量状态丢失
```
而且存在的另一个问题就是，当变量状态更新之后，UI 并不会自动更新，需要我们手动调用函数来更新UI，这个
时候状态的管理就更复杂了，当状态更新后，我们需要手动更新UI，这个过程中状态又会丢失，所以我们又不得不
在更新UI前保存状态，并且在下次脚本执行时恢复状态。

这里就有了钩子函数的概念，即useState函数就是一个钩子函数，它可以帮助我们管理状态，并且自动更新UI。
除了useState函数，React还提供了其他一些钩子函数，比如useEffect函数，它可以帮助我们管理副作用，比如
定时器、事件监听等。

## useRef函数
useState函数适用的是管理一些需要在屏幕上展示的信息，因为这些信息往往需要实时更新，而useRef函数则适用于
管理一些不需要在屏幕上展示的信息，比如DOM元素、计时器ID，与useState相比，useRef有以下特点：
* 可以在重新渲染之间 存储信息（普通对象存储的值每次渲染都会重置）。
* 改变它 不会触发重新渲染（状态变量会触发重新渲染）。
* 对于组件的每个副本而言，这些信息都是本地的（外部变量则是共享的）。

所以我们可以把useRef视作是一个组件内部的全局变量，它可以在组件的整个生命周期中保持不变，它仅在组件的第一次渲染时初始化一次，
当然我们后续也可以修改和获取这个变量的值。

## useEffect函数
useEffect函数是React中用于管理副作用的一个函数，它可以帮助我们管理一些需要在组件渲染完成后执行的代码，比如定时器、事件监听等。
所谓副作用，就是指和组件渲染无关的代码，比如定时器、事件监听等。

根据React官方文档，useEffect函数接受两个参数，分别是 `（setup, dependencies?）`，setup参数是一个函数，它的函数体内的代码将在
组件渲染完毕后（即组件函数调用完毕后）被执行，这个函数还可以返回一个函数，这个返回的函数将在组件卸载时被执行，总的来说就是一个清理函数。
dependencies参数是一个数组，它指定了setup函数所依赖的变量，如果这个数组中的变量发生变化，那么setup函数将被重新执行。

## 实战-自定义Hook函数
有了useRef函数和useEffect函数，我们可以实现一些自定义的功能，比如，我们可能想知道一些变量之前的状态是什么：
```javascript
function usePrevious(value) {
  const ref = useRef();
  useEffect(() => {
    ref.current = value;
  });
  return ref.current;
}
```
这是一个自定义的Hook函数，用来获取变量之前的值。它的原理是Ref对象的唯一性，它仅在组件第一次被渲染时进行一次初始化，而useEffect函数注册
的setup函数又只会在组件被渲染完毕后才执行（即它是在组件函数的最后才被执行的），所以usePrevious函数返回值的行为是先于更新Ref的值的，
所以usePrevious函数返回的值就是变量之前的状态了。

# 组件



